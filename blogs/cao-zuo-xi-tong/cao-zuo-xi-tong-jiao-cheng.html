<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统 | 枫情</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/fengqingblog/favicon.ico">
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/UsernameFull/l2d@0.2/js/frame/live2dcubismcore.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <meta name="description" content="枫情博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/fengqingblog/assets/css/0.styles.0b1977d4.css" as="style"><link rel="preload" href="/fengqingblog/assets/js/app.cbcc9409.js" as="script"><link rel="preload" href="/fengqingblog/assets/js/3.0311bc7f.js" as="script"><link rel="preload" href="/fengqingblog/assets/js/1.d92f2aba.js" as="script"><link rel="preload" href="/fengqingblog/assets/js/12.786bcb46.js" as="script"><link rel="prefetch" href="/fengqingblog/assets/js/10.c60a27ad.js"><link rel="prefetch" href="/fengqingblog/assets/js/11.6fa34246.js"><link rel="prefetch" href="/fengqingblog/assets/js/13.40377fce.js"><link rel="prefetch" href="/fengqingblog/assets/js/4.a7baac49.js"><link rel="prefetch" href="/fengqingblog/assets/js/5.d9bb39ec.js"><link rel="prefetch" href="/fengqingblog/assets/js/6.5a77485d.js"><link rel="prefetch" href="/fengqingblog/assets/js/7.5baeafbf.js"><link rel="prefetch" href="/fengqingblog/assets/js/8.bcdfee27.js"><link rel="prefetch" href="/fengqingblog/assets/js/9.e25a900f.js">
    <link rel="stylesheet" href="/fengqingblog/assets/css/0.styles.0b1977d4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-3def6117><div data-v-3def6117><div id="loader-wrapper" class="loading-wrapper" data-v-2c578df8 data-v-3def6117 data-v-3def6117><div class="loader-main" data-v-2c578df8><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-70a509e9 data-v-3def6117 data-v-3def6117><h3 class="title" data-v-70a509e9 data-v-70a509e9>枫情</h3> <p class="description" data-v-70a509e9 data-v-70a509e9>枫情博客</p> <label id="box" class="inputBox" data-v-70a509e9 data-v-70a509e9><input type="password" value="" data-v-70a509e9> <span data-v-70a509e9>Konck! Knock!</span> <button data-v-70a509e9>OK</button></label> <div class="footer" data-v-70a509e9 data-v-70a509e9><span data-v-70a509e9><i class="iconfont reco-theme" data-v-70a509e9></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-70a509e9>vuePress-theme-reco</a></span> <span data-v-70a509e9><i class="iconfont reco-copyright" data-v-70a509e9></i> <a data-v-70a509e9><span data-v-70a509e9>枫情</span>
            
          <span data-v-70a509e9>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-3def6117><header class="navbar" data-v-3def6117><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fengqingblog/" class="home-link router-link-active"><img src="/fengqingblog/avatar.jpg" alt="枫情" class="logo"> <span class="site-name">枫情</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fengqingblog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fengqingblog/categories/算法练习/" class="nav-link"><i class="undefined"></i>
  算法练习
</a></li><li class="dropdown-item"><!----> <a href="/fengqingblog/categories/操作系统/" class="nav-link"><i class="undefined"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><a href="/fengqingblog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/fengqingblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://gitee.com/feng-qing" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-3def6117></div> <aside class="sidebar" data-v-3def6117><div class="personal-info-wrapper" data-v-1a7245e0 data-v-3def6117><img src="/fengqingblog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1a7245e0> <h3 class="name" data-v-1a7245e0>
    枫情
  </h3> <div class="num" data-v-1a7245e0><div data-v-1a7245e0><h3 data-v-1a7245e0>3</h3> <h6 data-v-1a7245e0>Articles</h6></div> <div data-v-1a7245e0><h3 data-v-1a7245e0>2</h3> <h6 data-v-1a7245e0>Tags</h6></div></div> <ul class="social-links" data-v-1a7245e0></ul> <hr data-v-1a7245e0></div> <nav class="nav-links"><div class="nav-item"><a href="/fengqingblog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fengqingblog/categories/算法练习/" class="nav-link"><i class="undefined"></i>
  算法练习
</a></li><li class="dropdown-item"><!----> <a href="/fengqingblog/categories/操作系统/" class="nav-link"><i class="undefined"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><a href="/fengqingblog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/fengqingblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://gitee.com/feng-qing" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html" aria-current="page" class="active sidebar-link">操作系统</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-70a509e9 data-v-3def6117><h3 class="title" data-v-70a509e9 data-v-70a509e9>操作系统</h3> <!----> <label id="box" class="inputBox" data-v-70a509e9 data-v-70a509e9><input type="password" value="" data-v-70a509e9> <span data-v-70a509e9>Konck! Knock!</span> <button data-v-70a509e9>OK</button></label> <div class="footer" data-v-70a509e9 data-v-70a509e9><span data-v-70a509e9><i class="iconfont reco-theme" data-v-70a509e9></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-70a509e9>vuePress-theme-reco</a></span> <span data-v-70a509e9><i class="iconfont reco-copyright" data-v-70a509e9></i> <a data-v-70a509e9><span data-v-70a509e9>枫情</span>
            
          <span data-v-70a509e9>2021 - </span>
          2022
        </a></span></div></div> <div data-v-3def6117><main class="page"><section><div class="page-title"><h1 class="title">操作系统</h1> <div data-v-71eee331><i class="iconfont reco-account" data-v-71eee331><span data-v-71eee331>枫情</span></i> <i class="iconfont reco-date" data-v-71eee331><span data-v-71eee331>11/12/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-71eee331><span class="tag-item" data-v-71eee331>操作系统</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="操作系统教程"><a href="#操作系统教程" class="header-anchor">#</a> 操作系统教程</h1> <h2 id="第六章-并发程序设计"><a href="#第六章-并发程序设计" class="header-anchor">#</a> 第六章 并发程序设计</h2> <h3 id="_6-1-并发程序设计"><a href="#_6-1-并发程序设计" class="header-anchor">#</a> 6.1 并发程序设计</h3> <h4 id="_6-1-1-并发程序设计概念"><a href="#_6-1-1-并发程序设计概念" class="header-anchor">#</a> 6.1.1 并发程序设计概念</h4> <h5 id="_1、顺序程序设计"><a href="#_1、顺序程序设计" class="header-anchor">#</a> 1、顺序程序设计</h5> <p>概念：程序是实现算法的操作序列</p> <p><strong>内部顺序性</strong>：每个程序<strong>在处理器上</strong>执行是严格有序的称为程序执行的内部顺序性</p> <p><strong>外部顺序性</strong>：把一个具体问题的求解过程设计成<strong>一个程序</strong>或者<strong>若严格顺序执行的程序序列</strong>，这称为程序执行的外部顺序性</p> <p><strong>顺序程序设计的特性：</strong></p> <ul><li>程序执行的顺序性：程序指令执行是严格按序的</li> <li>计算机环境的封闭性：程序运行时如同独占操作系统保护的资源</li> <li>计算结果的确认性：程序执行结果与执行速度和执行时段无关</li> <li>计算过程的可在现性：程序对相同数据集的执行轨迹是确定的</li></ul> <h5 id="_2、并发程序设计"><a href="#_2、并发程序设计" class="header-anchor">#</a> 2、并发程序设计</h5> <p>多道程序设计让多个程序同时进入内存去竞争处理器以获得运行机会，与外设以及不同外设之间的并行度，一次提高处理器的利用率</p> <p>OS允许计算机系统在一个时间段内存在多个正在运行的进程，即允许多个进程并发执行</p> <p>OS保证按照“顺序程序设计”方法编制的程序在并发执行时不受影响，如同独占计算机</p> <p>这些按照顺序程序设计思想编制的进程在OS中并发执行属于无关的并发进程</p> <p><strong>并发程序设计的引入例-顺序程序设计</strong></p> <p>循环地(从输入机读78秒再计算52秒再向磁带机输出20秒)</p> <p>按照顺序程序设计方法，设计成如下一个程序：</p> <p>while(1) {input，process，output }</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151028277.png" alt="image-20211215102803931"></p> <p>处理器利用率：52/(78+52+20)≈35%</p> <p>并发程序设计的引入例-并发程序设计</p> <p>换一种设计思路，设计3个独立运行的程序，让它们同时进入多道程序系统去并发执行</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> while(1) {input，send }

 while(1) {receive，process，send }

 while(1) { receive，output }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151030087.png" alt="image-20211215103053045"></p> <p>处理器利用率：(52<em>n) /(78+52</em>n+20*n)≈72%</p> <p>并发程序设计：把一个具体问题求解设计成若干个课同时执行的程序模块的方法</p> <p>并发程序设计的特性：</p> <ul><li>并行性：多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行，<strong>提高了计算效率</strong></li> <li>共享性：多个进程共享软件资源</li> <li>交互性：多个进程并发执行存在制约，<strong>增加了程序设计的难度</strong></li></ul> <h4 id="_6-1-2-并发进程的制约关系"><a href="#_6-1-2-并发进程的制约关系" class="header-anchor">#</a> 6.1.2 并发进程的制约关系</h4> <h5 id="_1、无关与交互的并发进程"><a href="#_1、无关与交互的并发进程" class="header-anchor">#</a> 1、无关与交互的并发进程</h5> <p><strong>无关的并发进程</strong>：一组并发进程分别在<strong>不同</strong>的变量集合上运行，一个进程的执行与其他并发进程的进展无关</p> <p><strong>交往的并发进程</strong>：一组并发进程<strong>共享</strong>某些变量，一个进程的执行可能影响其他并发进程的结果</p> <h5 id="_2、与时间相关的程序设计错误"><a href="#_2、与时间相关的程序设计错误" class="header-anchor">#</a> 2、与时间相关的程序设计错误</h5> <p>对于一组交往的并发进程，执行的相对速度无法相互控制</p> <p>如果程序设计不当，可能出现各种”与时间有关的“错误</p> <ul><li><p>表现1：结果错误</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Int A[1..m]		// 机票数共享变量
process Ti {    // i = 1, 2, … 
 	Int Xi;
   按旅客定票要求找到航班j；
	Xi = A[j];
	if (Xi&gt;=1)  { 
           Xi = Xi - 1; 
           A[j] = Xi;
           {输出一张票}；
	} else {输出票已售完}；
}
进程1在此区间内被中断，进程2又卖此航班的票
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p>表现2：永远等待</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Int x；	//记录空闲内存量的共享变量
procedure borrow (Int B) {
   if  (B&gt;x)  //此处中断
      {进入等待队列等待主存资源} //永远等待
   x=x-B; {修改主存分配表, 获得主存资源} 
}
procedure return (int B) {
      x=x+B;
      {修改主存分配表}
      {释放等主存资源的进程} //全部归还
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ul> <h5 id="_3、进程执行的制约关系"><a href="#_3、进程执行的制约关系" class="header-anchor">#</a> 3、进程执行的制约关系</h5> <p>制约关系包括两类：进程互斥和进程同步</p> <p><strong>进程互斥</strong>：并发进程之间因<strong>相互争夺独占性资源</strong>而产生的竞争制约关系</p> <p><strong>进程同步</strong>：并发进程之间<strong>为完成共同任务基于某个条件来协调执行先后关系</strong>而产生的协作制约关系</p> <p><strong>竞争是一种特殊的协作</strong>，<strong>进程互斥是一种特殊的进程同步关系</strong></p> <h3 id="_6-2-临界区管理"><a href="#_6-2-临界区管理" class="header-anchor">#</a> 6.2 临界区管理</h3> <h4 id="_6-2-1-临界区概念"><a href="#_6-2-1-临界区概念" class="header-anchor">#</a> 6.2.1 临界区概念</h4> <h5 id="_1、互斥和临界区"><a href="#_1、互斥和临界区" class="header-anchor">#</a> 1、互斥和临界区</h5> <p>临界资源：互斥共享变量所代表的资源，即一次只能被一个进程使用的资源</p> <p>临界区：指并发进程中互斥共享变量相关的程序段</p> <p>多个并发进程访问临界区资源时，存在竞争制约关系，如果两个进程同时停留在相关的临界区内，就会出现与时间相关的错误</p> <h5 id="_2、临界区的描述"><a href="#_2、临界区的描述" class="header-anchor">#</a> 2、临界区的描述</h5> <p>确定临界资源</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>shared &lt;variable&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>确定临界区</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>region  &lt;variable&gt;  do &lt; statement_list&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>两个进程的临界区有相同的临界资源就是相关的临界区，必须互斥进入</p> <p>两个临界区不相关，进入就没有限制</p> <h5 id="_3、临界区管理的三个要求"><a href="#_3、临界区管理的三个要求" class="header-anchor">#</a> 3、临界区管理的三个要求</h5> <ul><li>一次至多允许一个进程停留在相关的临界区内</li> <li>一个进程不能无限止地停留在临界区内（如果一有进程在临界区中，试图进入此临界区的其他进程应等待）</li> <li>一个进程不能无限止地等待进入临界区（进入临界区内的进程应在有限时间内退出，以便让等待队列中等待的进程进入）</li></ul> <h5 id="_4、临界区的嵌套使用"><a href="#_4、临界区的嵌套使用" class="header-anchor">#</a> 4、临界区的嵌套使用</h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151116088.png" alt="image-20211215111644000"></p> <h4 id="_6-2-2-临界区管理实现的尝试"><a href="#_6-2-2-临界区管理实现的尝试" class="header-anchor">#</a> 6.2.2 临界区管理实现的尝试</h4> <h5 id="_1、临界区管理-尝试一"><a href="#_1、临界区管理-尝试一" class="header-anchor">#</a> 1、<strong>临界区管理：尝试一</strong></h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151447264.png" alt="image-20211215144618318"></p> <p>在p1进入，且没有将inside置为为true，p2也进入导致同时进入</p> <h5 id="_2、临界区管理-尝试二"><a href="#_2、临界区管理-尝试二" class="header-anchor">#</a> 2、<strong>临界区管理：尝试二</strong></h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151451477.png" alt="image-20211215145143346"></p> <p>有可能每个进程都将自己的标志置为true，从而出现死循环，这时没有进程能在有限时间内进入临界区</p> <h5 id="_3、解决思路"><a href="#_3、解决思路" class="header-anchor">#</a> 3、<strong>解决思路：</strong></h5> <p>问题：框内的（测试锁、建立锁）两条指令执行过程不能中断</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151457359.png" alt="image-20211215145715209"></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151458146.png" alt="image-20211215145800061"></p> <h4 id="_6-2-3-临界区管理实现的硬件方式"><a href="#_6-2-3-临界区管理实现的硬件方式" class="header-anchor">#</a> 6.2.3 临界区管理实现的硬件方式</h4> <h5 id="_1、关中断"><a href="#_1、关中断" class="header-anchor">#</a> 1、关中断</h5> <p>实现互斥最简单的方法是在进程中进入临界区时关中断，进程退出临界区时开中断。</p> <p>关中断的方法简单且有效，操作系统原语就是基于该思路实现的</p> <p><strong>但该方式不适合作为通用的互斥机制:</strong></p> <ul><li>临界区的指令长度应短小精悍，否则关中断的时间过长会影响性能和系统效率</li> <li>他不适用于多处理系统，一个处理器关中断并不能防止进程在其他处理器上执行相同的临界区代码</li> <li>若将这项权利赋予用户也在危险，如果用户未开中断，则系统可能因此而终止</li></ul> <h5 id="_2、测试并设置指令"><a href="#_2、测试并设置指令" class="header-anchor">#</a> 2、测试并设置指令</h5> <p>使用硬件所提供的测试并设置（test and set TS）机器指令</p> <p>测试并建立指令的逻辑是，<strong>如果锁在（真值），则上锁（改为假）返回上锁成功，否则返回返回上锁失败</strong></p> <p><strong>每一个进程在进入临界区前循环测试能否得到锁，得到则进入，出临界区前卸锁</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">TS</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>				
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>false<span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">=</span>true<span class="token punctuation">;</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-c line-numbers-mode"><pre class="language-c"><code>Boolean lock<span class="token punctuation">;</span>
lock <span class="token operator">=</span> false<span class="token punctuation">;</span>				<span class="token comment">// 临界区可用</span>
process Pi  <span class="token punctuation">{</span>      				<span class="token comment">// i = 1,2,…,n</span>
     Boolean pi<span class="token punctuation">;</span>
     repeat pi<span class="token operator">=</span><span class="token function">TS</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> until pi<span class="token punctuation">;</span>	<span class="token comment">// 循环请求锁</span>
     临界区<span class="token punctuation">;</span>
     lock <span class="token operator">=</span> false；				<span class="token comment">// 解锁</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="_3、对换指令"><a href="#_3、对换指令" class="header-anchor">#</a> 3、对换指令</h5> <p>类似功能的指令还有swap，它是一条交换指令。**建立一把锁，假值表示未上锁。**进临界区前，<strong>试图把真值换进去，表示上锁</strong>，如果换出来的是真值，表示已经有进程进去了，忙式测试，直到换出假值，表示本进程获得锁并成功上锁进入临界区，<strong>出临界区卸锁</strong></p> <p>实现临界区管理看的硬件设施</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">swap</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    temp<span class="token operator">=</span>a<span class="token punctuation">;</span> a<span class="token operator">=</span>b<span class="token punctuation">;</span> b<span class="token operator">=</span>temp<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-c line-numbers-mode"><pre class="language-c"><code>Boolean lock<span class="token punctuation">;</span>
lock <span class="token operator">=</span> false<span class="token punctuation">;</span>		<span class="token comment">//临界区可用</span>
process Pi   <span class="token punctuation">{</span>     		<span class="token comment">// i = 1,2,…,n</span>
    Boolean pi<span class="token punctuation">;</span>
    pi <span class="token operator">=</span> true<span class="token punctuation">;</span>
    repeat <span class="token function">swap</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> pi<span class="token punctuation">)</span> until <span class="token operator">!</span>pi；<span class="token comment">//循环请求锁</span>
    临界区<span class="token punctuation">;</span>
    lock <span class="token operator">=</span> false；		<span class="token comment">//解锁</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="_4、总结"><a href="#_4、总结" class="header-anchor">#</a> 4、总结：</h5> <ul><li><p>TS和swap指令均是忙式等待，效率低</p></li> <li><p>简单的解决办法是在进出临界区时开关中断，这样临界区执行就不会中断了，执行就有原子性</p> <p>关中断；临界区；开中断</p> <p>操作系统原语就采用这种实现思路</p> <p>但是，临界区的指令长度应该短小精悍，这样才能保证系统效率</p> <p>不建议用户程序使用，滥用是可怕的</p></li></ul> <h3 id="_6-3-pv操作"><a href="#_6-3-pv操作" class="header-anchor">#</a> 6.3 PV操作</h3> <h4 id="_6-3-1-pv操作与进程互斥"><a href="#_6-3-1-pv操作与进程互斥" class="header-anchor">#</a> 6.3.1 PV操作与进程互斥</h4> <h5 id="_1、针对硬件式管理方式问题的提出"><a href="#_1、针对硬件式管理方式问题的提出" class="header-anchor">#</a> 1、针对硬件式管理方式问题的提出</h5> <ul><li>TS或swap指令管理临界区，采用忙式轮询，浪费系统CPU时间，将测试能否进入临界区的责任推给了各个竞争的进程，削弱了系统的可靠性，加重了用户编程负担，利用效率低</li> <li>关开中断管理临界区，不便交给用户程序使用</li> <li>参考：操作系统访问硬件资源时采用“请求-等待-中断恢复”方式</li></ul> <h5 id="_2、信号量的构思"><a href="#_2、信号量的构思" class="header-anchor">#</a> 2、信号量的构思</h5> <p>信号量：一种可动态定义的软件源</p> <p>通过信号量的声明、信号量的撤销、资源的申请、资源的归还对临界区进行有效的管理</p> <ul><li>核心数据结构：等待进程队列</li> <li>信号量声明：资源报到，建立队列</li> <li>申请资源的原语：若申请，得不到资源，调用进程入队等待</li> <li>归还资源的原语：若队列中有等待进程，需释放</li> <li>信号量撤销：资源注销，撤销队列</li></ul> <h5 id="_3、记录型信号量的定义"><a href="#_3、记录型信号量的定义" class="header-anchor">#</a> 3、记录型信号量的定义</h5> <ul><li><p>记录型信号量：一种带数值的软件资源</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">{</span>
         <span class="token keyword">int</span> value<span class="token punctuation">;</span>		 <span class="token comment">// 信号量值</span>
         <span class="token keyword">struct</span> <span class="token class-name">pcb</span> <span class="token operator">*</span>list<span class="token punctuation">;</span> <span class="token comment">// 信号量等待进程队列指针</span>
 <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>每个信号量建立一个等待进程队列</p></li> <li><p>每个信号量相关一个整数值</p> <p>正值表示资源可复用次数</p> <p>0值表示无资源且无进程等待</p> <p>负值表示等待队列中进程个数</p></li></ul> <h5 id="_4、pv操作"><a href="#_4、pv操作" class="header-anchor">#</a> 4、pv操作</h5> <p><strong>P操作原语与V操作原语</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>procedure <span class="token function">P</span><span class="token punctuation">(</span>semaphore<span class="token operator">:</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   s <span class="token operator">=</span> s – <span class="token number">1</span><span class="token punctuation">;</span>       	<span class="token comment">//信号量减去1 </span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">W</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//若信号量小于0，则调用进程</span>
                           	  被置成等待信号量s的状态 
<span class="token punctuation">}</span>
procedure <span class="token function">V</span><span class="token punctuation">(</span>semaphore<span class="token operator">:</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   s <span class="token operator">:</span><span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 		<span class="token comment">//信号量加1 </span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">R</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//若信号量小于等于0，则释放</span>
                        <span class="token comment">// 一个等待信号量s的进程 </span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>PV操作解决进程互斥问题框架</strong></p> <p>与TS指令类似，PV操作也是用了测试信号量的方法决定了进程是否进入临界区。但是不同的是，PV操作只需要对信号量测试一次，而TS指令必须反复测试，从而可能造成忙式等待</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>semaphore s<span class="token punctuation">;</span>
s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
cobegin
	 process Pi <span class="token punctuation">{</span>
		  ……
		  <span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		  临界区；
		  <span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		  ……
	 <span class="token punctuation">}</span>
coend<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>假设在一个有n个进程互斥使用某个临界区的系统中，信号量mutex初值为1，取值范围是-（n-1）~1，当其值等于-（n-1），表明此时有一个进程的临界区内执行，且n-1个进程在信号量队列中等待</p> <h5 id="pv操作解决机票问题"><a href="#pv操作解决机票问题" class="header-anchor">#</a> PV操作解决机票问题</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>Int A[m];
Semaphore s;
s = 1;
cobegin
process Pi {
	int Xi;
	Li:按旅客定票要求找到A[j]；
	P(s)；
	Xi = A[j];
	If (Xi&gt;=1) { 
	Xi=Xi-1; 
	A[j]=Xi; 
	V(s); 输出一张票；
	} 	
	else {
    V(s); 输出票已售完;
    }
	goto Li;
}
coend
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>只有相同航班的票数才是相关的临界资源所以用一个信号量处理全部机票回影响进程并发度</p> <p><strong>改进之后</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Int A[m];
Sema phore s[m];
For (int j=0;j&lt;m;i++) s[j] = 1;
cobegin
process Pi {
	int Xi;
	L1:按旅客定票要求找到A[j]；
	P(s[j])；
	Xi = A[j];
	If (Xi&gt;=1) { 
		Xi=Xi-1; 
		A[j]=Xi;
        V(s[j]); 输出一张票；
	} else { 
		V(s[j]); 输出票已售完；
	}
	goto L1;
}
coend;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="_6-3-2-pv操作与进程同步"><a href="#_6-3-2-pv操作与进程同步" class="header-anchor">#</a> 6.3.2 PV操作与进程同步</h4> <h5 id="_1、pv操作解决进程同步问题的基本思路"><a href="#_1、pv操作解决进程同步问题的基本思路" class="header-anchor">#</a> 1、PV操作解决进程同步问题的基本思路</h5> <p>进程同步：并发进程为完成共同任务基于某个条件来协调，一个进程的执行等待来自于其他进程的消息</p> <p>同一个同步信号量的P操作和V操作不在一个进程里</p> <p>2、一个进程的执行等待来自于其他进程的消息</p> <p><strong>解决的基本思路</strong></p> <ol><li>定义一个信号量：其数值代表可用消息数</li> <li>等待消息进程：执行P，无消息则可等待</li> <li>发出消息进程：执行V，有等待进程则释放</li></ol> <h5 id="_2、pv操作解决生产者-消费者问题初探"><a href="#_2、pv操作解决生产者-消费者问题初探" class="header-anchor">#</a> 2、PV操作解决生产者-消费者问题初探</h5> <p><strong>1、分析问题</strong></p> <p>生产者和消费者共享缓冲区</p> <p>缓冲区有空位时，生产者放入产品，否则等待</p> <p>缓冲区有产品时，消费者等待可取出产品，否则等待</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151833569.png" alt="image-20211215183305452"></p> <p><strong>2、程序框架</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151833097.png" alt="image-20211215183341008"></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151834342.png" alt="image-20211215183425266"></p> <p><strong>3、解决思路</strong></p> <p>同步关系1：消费者一开始在等待产品到来，考虑设置一个信号量（等待产品）；一开始无产品，初始值为0</p> <p>同步关系2：消费者则在等待缓冲区中有空位，也设置一个信号量（等待缓冲区）；一开始缓冲区有空位，初始值为 1</p> <p>4、<strong>程序实现</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151838057.png" alt="image-20211215183827969"></p> <h4 id="_6-3-3-生产者-消费者问题探究"><a href="#_6-3-3-生产者-消费者问题探究" class="header-anchor">#</a> 6.3.3 生产者-消费者问题探究</h4> <h5 id="_1、生产消费者问题"><a href="#_1、生产消费者问题" class="header-anchor">#</a> 1、生产消费者问题</h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151840534.png" alt="image-20211215184054461"></p> <h5 id="_2、pv-解决生产者1-消费者1缓冲区问题"><a href="#_2、pv-解决生产者1-消费者1缓冲区问题" class="header-anchor">#</a> 2、PV 解决生产者1--消费者1缓冲区问题</h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151842371.png" alt="image-20211215184250307"></p> <h5 id="_3、pv解决生产者1-消费者n缓冲区问题"><a href="#_3、pv解决生产者1-消费者n缓冲区问题" class="header-anchor">#</a> 3、PV解决生产者1--消费者N缓冲区问题</h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151845460.png" alt="image-20211215184526353"></p> <h5 id="_4、pv解决n生产者消费者n缓冲区问题"><a href="#_4、pv解决n生产者消费者n缓冲区问题" class="header-anchor">#</a> 4、PV解决N生产者消费者N缓冲区问题</h5> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151915457.png" alt="image-20211215191407004"></p> <h5 id="_5、总结"><a href="#_5、总结" class="header-anchor">#</a> 5、总结</h5> <ul><li>一个生产对一个消费的：设置一个缓冲区和一个拿和已给可放两个变量</li> <li>一个生产者对N个消费者者：设置多个缓冲区，一个可拿和一个可放变量，引入下一个放索引和下一个拿索引</li> <li>N个生产对N个消费者：设置多个缓冲区，设置一个可拿和可放变量，引入下一个放索引和下一个拿索引，再引入两个互斥变量（消费者互斥和生产者互斥）</li></ul> <h5 id="_6、苹果橘子问题"><a href="#_6、苹果橘子问题" class="header-anchor">#</a> 6、苹果橘子问题</h5> <p><strong>问题分析</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112151924853.png" alt="image-20211215192435651"></p> <p><strong>PV操作解决苹果橘子问题</strong></p> <p>定义一个空位变量</p> <p>定义一个苹果数量变量</p> <p>定义一个橘子数据变量</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202112162307618.png" alt="image-20211215192936577"></p> <h3 id="_6-4-管程"><a href="#_6-4-管程" class="header-anchor">#</a> 6.4 管程</h3> <h4 id="_6-4-1-管程概述"><a href="#_6-4-1-管程概述" class="header-anchor">#</a> 6.4.1 管程概述</h4> <h5 id="_1、管程概念的提出"><a href="#_1、管程概念的提出" class="header-anchor">#</a> 1、管程概念的提出</h5> <ul><li>管程试图抽象相关并发进程对共享变量访问，以提供一个友善的并发程序设计开发环境</li> <li>管程是由若干公共变量及其说明和所有访问这些变量的过程所组成</li> <li>管程把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理，管程的局部变量只能由该管程的过程存取</li> <li>进程只能互斥地调用管程中的过程</li></ul> <h5 id="_2、概念和定义"><a href="#_2、概念和定义" class="header-anchor">#</a> 2、概念和定义</h5> <p>相对于信号量和PV操作实现的进程的同步与互斥时，对共享资源的管理分散于各个进程中，它们能够直接对变量进行处理，不利于系统对临界资源的管理。</p> <p>在进程共享内存的前提下，如果能集中和封装针对一个共享资源的所有访问，即将相关的的共享变量及其操作集中在一起进行控制和管理。</p> <p>基于抽象数据类型的原理提出新的同步机制——管程</p> <p><strong>基本思路</strong>：将分散在各个进程中的临界区集中管理，并将共享资源用户数据结构抽象地表示。</p> <p>管程是由若干局部公共变量及其声明和所有访问这些公共变量的过程所组成的软件模板</p> <p>管程的基本特征:</p> <ul><li><p>1.局部于管程的数据只能被局部于管程的过程所访问;</p></li> <li><p>2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据;</p></li> <li><p>3.每次仅允许一个进程在管程内执行某个内部过程。</p></li></ul> <p><strong>管程的属性：</strong></p> <ul><li>共享性</li> <li>安全性</li> <li>互斥性</li></ul> <p><strong>管程的基本形式</strong></p> <p><img src="C:%5CUsers%5Cfengq%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211215194125177.png" alt="image-20211215194125177"></p> <h5 id="_3、管程的规格定义与实现思路"><a href="#_3、管程的规格定义与实现思路" class="header-anchor">#</a> 3、管程的规格定义与实现思路</h5> <p>管程通过防止对一个资源的并发访问达到临界区的效果，它提供了一种实现互斥的简单途径，但是并未提供进程与其他进程通信或同步的手段</p> <p>当一个进程进入管程并调用了其中一个过程，而该过程执行时发现因资源不能满足而无法继续执行下去时，应阻塞该进程，同时还需开放管程让之前被挡在管程外且排序靠前的一个进程进入管程</p> <p>解决方法：使用称作条件变量的同步机制，让阻塞进程的临时放弃管程的控制权，在适合时刻检测管程内状态的变化，已恢复进程执行</p> <p><strong>管程的条件变量</strong></p> <ul><li>条件变量（condition variables）：当调用管程过程的进程无法运行时，用于阻塞进程的信号量</li> <li>同步原语wait：当一个管程过程发现无法继续时（如发现没有可用资源时），它在某些条件变量上执行wait，这个动作引起调用进程阻塞</li> <li>同步原语signal：用于释放在条件变量上阻塞的进程</li></ul> <p><strong>条件变量</strong>：出现管程内的一种数据结构，且只有在管程总才能被访问，其功能是当调用管程过程的进程无法运行时，用于阻塞进程的信号量，它对管程内的所有过程时是全局的</p> <p>条件变量也是一种信号量，但是它并不是一种信号量，但它并不是PV操作中纯碎的计数信号量，没有与条件变量关联的值，也不能像信号量那样积累供以后使用，仅仅起到阻塞进程队列的作用</p> <p><strong>管程的执行模型</strong></p> <p><img src="C:%5CUsers%5Cfengq%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211215194553895.png" alt="image-20211215194553895"></p> <p><strong>操作它的方式：</strong></p> <p>wait();操作。当一个进程发现无法继续时，将在某些条件变量上执行wait操作，使得调用过程被阻塞</p> <p>signal();操作用于释放（唤醒）在条件上阻塞的进程</p> <p>管程有一个进程恢复后，两个进程的占用管程的问题，一个进程Q在等待，当进程P执行signal（）操作后，进程Q被释放。</p> <p>可以有以下两种处理方式：</p> <p>进程P等待直至进程Q退出管程，或者进程Q等待另一个条件（默认）（霍尔）</p> <p>进程Q等待直至进程P退出管程，或者P等待另一个条件（汉森，故管程的signal操作是过程中体的最后一个操作）</p> <h4 id="_6-4-2-霍尔管程"><a href="#_6-4-2-霍尔管程" class="header-anchor">#</a> 6.4.2 霍尔管程</h4> <p>霍尔管程是一种具普适性的管程实现方法，它使用了PV操作原语实现对管程中过程的互斥调用功能，同时实现对共享资源的互斥使用的管理。每当有进程等待资源时，霍尔管程将让执行signal操作的进程阻塞自己，直到被它释放的进程退出管程或产生了其他的等待条件为止。</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103150.png" alt="image-20211121234005527" style="zoom:50%;"> <p>与汉深管程的实现区别就是：该方法不要signal操作是过程的最后一个操做，且wait和signal操作可被设计成两个可以中断的过程，非原语</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103151.png" alt="image-20211121234131025" style="zoom:50%;"> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103152.png" alt="image-20211121234318851" style="zoom:50%;"> <h4 id="_6-4-3-霍尔管程的例子"><a href="#_6-4-3-霍尔管程的例子" class="header-anchor">#</a> 6.4.3 霍尔管程的例子</h4> <p><strong>1、解决哲学家就餐的问题</strong></p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103153.png" alt="image-20211121234531308" style="zoom:33%;"> <p><strong>2、管程解决读者-写者问题</strong></p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103154.png" alt="image-20211121234621051" style="zoom:50%;"> <h3 id="_6-5-进程通信"><a href="#_6-5-进程通信" class="header-anchor">#</a> 6.5 进程通信</h3> <p>6.5.1 进程的通信</p> <p>系统中的交互进程可以通过信号量及PV操作实现进程互斥和同步。</p> <p>通过交换信号量已达到递交产品和使用缓冲区的目的，这可以看作是一种<strong>低级通信方式</strong></p> <p>大量信息传递可使用的<strong>高级通信方式</strong>——进程间通信机制</p> <p><strong>1、进程直接通信</strong></p> <p>在进程直接通信方式下，企图发送或接收信息的每个进程必须指出信件发给谁或从谁哪里接收信件</p> <p>send(P,信件);</p> <p>recevice(Q,信件);</p> <p><strong>2、进程间接通信</strong></p> <p>采用间接通信方式时，进程间发送或接收信件通过一个共享的数据结构——信箱</p> <p>信箱是存放信件的存储区域，每个信箱可以分成信箱特征和信箱体两部分</p> <p>信箱特征：指出信箱的容量、信件格式、存放信件位置的指针</p> <p>信箱体：存放信件</p> <p>间接方式：</p> <p>send(A,信件);将信件发送到信箱A</p> <p>recevice(A,信件);将信箱A接收信件A</p> <h4 id="_6-5-2-高级进程通信"><a href="#_6-5-2-高级进程通信" class="header-anchor">#</a> 6.5.2 高级进程通信</h4> <p>1、基于流的进程通信</p> <p>基于字节流的通信：多个进程可以使用一个共享的消息缓冲区，这个缓冲区将被组织成一个字节流，而非一个信件流</p> <p>发送者或称为发送信息的进程向消息缓冲区写入字节流，接收消息的进程则从消息缓冲区中读取字节流，只要缓冲区有足够的字节数，就可以读出来，如果没有足够的字节数，就去等待消息。</p> <p>2、基于RPC的高级通信规约</p> <p>远程调用（RPC）是目前在分布式系统中广泛采用的进程通信方法，他将单机环境下的过程调用扩展到分布式环境中，允许不同计算机上的进程使用简单的过程调用和返回结果的方式进行交互</p> <p>客户机某个进程调用服务的一个过程，发出一条带有RPC的命令——》客户端存根委托她代理作为自己的代理——》调用执行远程过程低调用，打包参数成消息——》执行原语返送到服务器——》执行receive原语阻塞自己直到收到服务器的答复——》消息送回客户机后，客户端的内核找到消息并将其送给客户存根——》客户存根检查并拆开消息包，将取出的结果返回给调用的进程——》通过调用进程获得控制权并得到本次过程调用的结果。</p> <p>当消息到服务器之后，服务端的内核将消息传送到服务器存根——》服务器存根调用receive原语阻塞自己等带消息到达——》服务器存根拆包从消息中取出参数，调用服务器进程调用过程并返回结果——》当过程结束，服务器存根获取控制权，将结果打包成消息——》调用send原语请求内核将包含结果的消息发回给调用者——》服务器存根调用receive阻塞自己等待下一个消息</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103155.png" alt="image-20211121234709721" style="zoom:50%;"> <p>3、基于RPC/XDR的高级通信规约</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103156.png" alt="image-20211121234808893" style="zoom:50%;"> <h3 id="_6-6-死锁"><a href="#_6-6-死锁" class="header-anchor">#</a> 6.6 死锁</h3> <h4 id="_6-6-1-死锁的产生"><a href="#_6-6-1-死锁的产生" class="header-anchor">#</a> 6.6.1 死锁的产生</h4> <p><strong>1、死锁的定义</strong></p> <p>一个进程需要独占访问不止一个资源，系统允许多个进程并发执行共享系统资源时，可能会出现所有进程被永久阻塞的现象，叫死锁</p> <p>如果在一个进程集合中，每个进程都在等待只能由该集合中的另一个进程才能引发的事件，则成一组进程或系统此时发生了死锁。</p> <p><strong>2、死锁产生的举例</strong></p> <ul><li><p>竞争资源产生死锁</p> <p>进程P和进程Q执行时，相对速度无法预知，当进程P占用读卡机，进程Q占用请求打印机，进程P请求打印机，但打印机被进程Q占用。</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103158.png" alt="image-20211121210101747" style="zoom:50%;"></li> <li><p>PV操作使用不当产生死锁</p> <img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103159.png" alt="image-20211121210215740" style="zoom:50%;"></li> <li><p>同类资源分配不当引发起死锁</p> <p>资源m=5,进程n=5,需求资源k=2,采用分配策略是为每一个进程轮流分配，第一轮分配5个进程都有1个资源，但不满足需求便进行等待</p></li> <li><p>对临时性资源使用不加限制引起死锁</p> <p>进程通信时使用的信件可以看作一种临时性资源。</p> <p>p1(等s3)  --发送s1--&gt;  P2(等s1)    --s2--&gt;   P3(等s2)  --s3--&gt;  P1</p> <p>便形成一个资源的等待的状态。</p></li></ul> <h4 id="_6-6-2-死锁的防止"><a href="#_6-6-2-死锁的防止" class="header-anchor">#</a> 6.6.2 死锁的防止</h4> <p><strong>1、死锁产生的条件</strong></p> <ul><li>互斥条件</li> <li>占有和等待条件</li> <li>不剥夺条件</li> <li>循环等待条件</li></ul> <p>前三条件是死锁存在的必要条件，但不是充分条件，第四条件是前三个条件同时存在产生的结果。</p> <p><strong>破坏四个必要条件之一，就可以防止死锁</strong></p> <ul><li><strong>破坏互斥条件</strong>，使资源可同时访问不是互斥使用。（磁盘就可以采用该方法进行管理，但是有许多资源往往是不能同时访问的、SPOOLingd技术）</li> <li><strong>采用剥夺式调度方法可以破坏不剥夺条件</strong>，但是剥夺调度方法目前只适用于对主存和处理资源的分配。</li></ul> <p><strong>2、静态分配策略</strong>（<strong>破坏占有和等待条件</strong>）</p> <p>静态资源分配是一个进程必须再执行前就申请它需要的全部资源，并且直到他需要的资源都得到满足后才开始执行。</p> <p>分配之后，进程在执行中不再申请资源</p> <p>优点：实现简单</p> <p>缺点：降低了资源利用率</p> <p><strong>3、层次分配策略</strong>（<strong>阻止循环等待条件的出现</strong>）</p> <p>系统将资源分为多个层次</p> <p>一个进程得到某一层的一个资源后，他只能申请较高的一层</p> <p>一个进程要释放某层资源时，必须先释放所占用的较高层的资源</p> <p>一个进程获得一层的资源后，想要再次申请该层资源也要先释放本层资源。</p> <p>缺点：层次分配比静态分配实现上代价要大</p> <p>优点：提高了资源利用率，但是资源使用的次序和系统规定的次序不同，效率就不死很明显。</p> <h4 id="_6-6-3-死锁的避免"><a href="#_6-6-3-死锁的避免" class="header-anchor">#</a> 6.6.3 死锁的避免</h4> <p>不能防止死锁的产生、就尽量避免死锁</p> <p>银行家算法：检查申请者对各类资源的最大需求量，如果系统现存的各类资源可以满足它的最大需求量时，就满足当前的申请。</p> <p>银行家算法可以避免死锁，但是十分保守，资源利用率比较低。</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103160.png" alt="image-20211121210450951"></p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103659.png" alt="image-20211121210533249"></p> <h4 id="_6-6-4-死锁的检测"><a href="#_6-6-4-死锁的检测" class="header-anchor">#</a> 6.6.4 死锁的检测</h4> <p>对资源的的分配加以限制可以防止和避免死锁的发生，但不利于各进程对系统资源的充分共享。</p> <p>解决死锁问题的另一条途径是对资源的分配不加于限制，但是系统会定时运行一个死锁检测程序。</p> <p><strong>等待资源表和占用资源表</strong></p> <p>通过设置两张表格记录进程的使用资源的情况，即等待资源表记录每个被阻塞进程等待的资源，占用资源表记录每个进程占有的资源。</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103279.png" alt="image-20211121210633845"></p> <p>等待占用关系：如果有进程Pi等待资源rk，且rk被进程Pi占用，则说明Pi和Pj具有等待占用关系，记为W(Pi,Pj)，当出现W(Pi,Pj),W(Pj,Pk),...,W(Pl,Pm),W(Pm,Pi)时，系统中就存在一组循环等待资源的进程Pi，Pj....Pm,也就表明系统出现死锁。</p> <p><strong>死锁检测的方法</strong></p> <p>将两张表格中记录的进程使用和资源等待的情况用矩阵表示</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-imageimage-20211121210703175.png" alt="image-20211121210703175"></p> <p>当Pi等待被Pj占用的资源时，bij的值记为1，当Pi和Pj不存在等待占用关系时，bij的值记为0。</p> <p>死锁检测程序可用Warshall的传递闭包算法，A*[bij]</p> <p><img src="https://cdn.jsdelivr.net/gh/FengqWorld/studyImage/markdown-image202111220103161.png" alt="image-20211121210734166"></p> <p><strong>死锁的检测和解除</strong></p> <ul><li>结束所有进程的执行，并重新启动操作系统。</li> <li>撤销陷于死锁的所有进程，解除死锁，重新启动执行</li> <li>在进程执行过程中定时设置校验点，从校验点开始重执行，让进程回退，直到足以解决死锁</li> <li>中止一个卷入死锁的过程，以后再重新执行</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-65c007c6><li class="level-2" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#第六章-并发程序设计" class="sidebar-link reco-side-第六章-并发程序设计" data-v-65c007c6>第六章 并发程序设计</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-1-并发程序设计" class="sidebar-link reco-side-_6-1-并发程序设计" data-v-65c007c6>6.1 并发程序设计</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-2-临界区管理" class="sidebar-link reco-side-_6-2-临界区管理" data-v-65c007c6>6.2 临界区管理</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-3-pv操作" class="sidebar-link reco-side-_6-3-pv操作" data-v-65c007c6>6.3 PV操作</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-4-管程" class="sidebar-link reco-side-_6-4-管程" data-v-65c007c6>6.4 管程</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-5-进程通信" class="sidebar-link reco-side-_6-5-进程通信" data-v-65c007c6>6.5 进程通信</a></li><li class="level-3" data-v-65c007c6><a href="/fengqingblog/blogs/cao-zuo-xi-tong/cao-zuo-xi-tong-jiao-cheng.html#_6-6-死锁" class="sidebar-link reco-side-_6-6-死锁" data-v-65c007c6>6.6 死锁</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a008c6ba data-v-a008c6ba><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a008c6ba><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a008c6ba></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a008c6ba></path></svg></div><!----><div class="RibbonAnimation"></div><canvas id="vuepress-canvas-cursor"></canvas><div></div><APlayer audio="" fixed="true" mini="true" autoplay="autoplay" theme="#b7daff" loop="loop" order="random" preload="auto" volume="0.15" mutex="true" lrc-type="0" list-max-height="250" storage-name="vuepress-plugin-meting" id="aplayer-fixed"></APlayer><div class="kanbanniang" data-v-9007626c><div class="banniang-container" style="display:;" data-v-9007626c><div class="messageBox" style="right:88px;bottom:270px;display:none;" data-v-9007626c></div> <div class="operation" style="right:15px;bottom:100px;" data-v-9007626c><i class="kbnfont kbn-ban-home ban-home" data-v-9007626c></i> <i class="kbnfont kbn-ban-message message" data-v-9007626c></i> <i class="kbnfont kbn-ban-info info" data-v-9007626c></i> <i class="kbnfont kbn-ban-close close" data-v-9007626c></i></div> <div id="L2dCanvas" class="Canvas" style="position: absolute; bottom: -50px;z-index:100000" data-v-9007626c></div></div> <div class="showBanNiang" style="display:none;" data-v-9007626c>看板娘</div></div></div></div>
    <script src="/fengqingblog/assets/js/app.cbcc9409.js" defer></script><script src="/fengqingblog/assets/js/3.0311bc7f.js" defer></script><script src="/fengqingblog/assets/js/1.d92f2aba.js" defer></script><script src="/fengqingblog/assets/js/12.786bcb46.js" defer></script>
  </body>
</html>
